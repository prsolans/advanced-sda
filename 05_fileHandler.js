/**
 * Takes a generated data object, creates a prompt, calls the AI, 
 * and saves the resulting file to the specified subfolder.
 * @param {Object} docData The object of data generated by a ...Row function.
 * @param {GoogleAppsScript.Drive.Folder} subfolder The Google Drive folder to save the new file in.
 */
// Add logging to processAndCreateFile to debug the issue
function processAndCreateFile(docData, subfolder) {
    if (!docData) {
        Logger.log("processAndCreateFile skipped because docData was null.");
        return;
    }

    // Destructure all needed properties from the data object
    const {
        agreementType, language, firstParty, counterparty,
        contractNumber, // The document's own number
        parentMsaContractNumber // The number from the parent MSA for SOWs/COs
    } = docData;
    
    // Log the agreement type for debugging
    Logger.log(`processAndCreateFile - agreementType: "${agreementType}", language: "${language}", contractNumber: "${contractNumber}"`);

    // Generate a number if one isn't already set
    const finalContractNumber = contractNumber || generateContractNumber(agreementType);
    docData.contractNumber = finalContractNumber; 

    Logger.log("docData going into prompt:\n" + JSON.stringify(docData, null, 2));

    const role = 'This GPT is designated to generate realistic sample agreements for use during AI demonstrations. It is tailored to create agreements with specific legal language and conditions that can be analyzed to return structured information.';
    const prompt = createPrompt(docData);

    try {
        const responseFromOpenAI = PreSalesOpenAI.executePrompt4o(role, prompt);

        // Log before calling createFileInDriveV3
        Logger.log(`Calling createFileInDriveV3 with: agreementType="${agreementType}", language="${language}", contractNumber="${finalContractNumber}"`);
        
        // Pass the agreement type, language, and contract number to file creation
        const newFileId = createFileInDriveV3(responseFromOpenAI, agreementType, language, finalContractNumber);

        const newFile = DriveApp.getFileById(newFileId);
        newFile.moveTo(subfolder);
        newFile.setDescription(`Template for ${firstParty} and ${counterparty}`);

    } catch (error) {
        Logger.log(`Failed to create document for ${agreementType} with ${counterparty}. Original Error: ${error.message}`);
        // This includes the original error details in the message shown to the user.
        throw new Error(`Failed for ${agreementType}. Details: ${error.message}`);
    }
}

// Fixed version of createFileInDriveV3 that ensures proper naming
function createFileInDriveV3(html, agreementType, language, contractNumber) {
    // Debug logging
    Logger.log(`createFileInDriveV3 called with:`);
    Logger.log(`  agreementType: "${agreementType}"`);
    Logger.log(`  language: "${language}"`);
    Logger.log(`  contractNumber: "${contractNumber}"`);
    
    const languageAbbreviations = {
        Spanish: "[ES]",
        French: "[FR]",
        German: "[DE]",
        "Portuguese (PT)": "[PT]",
        "Portuguese (BR)": "[BR]",
        Japanese: "[JA]",
        English: "", // No prefix for English
    };

    // Get language prefix - default to empty string if not found or if English
    const langPrefix = (language && language !== 'English') ? (languageAbbreviations[language] || "") : "";

    // Use the provided contract number, or generate a new one if it doesn't exist
    const finalContractNumber = contractNumber || generateContractNumber(agreementType);

    // Build filename components - ENSURE agreementType is included
    const fileNameParts = [];
    
    // Only add language prefix if it exists
    if (langPrefix && langPrefix.length > 0) {
        fileNameParts.push(langPrefix);
    }
    
    // Add the agreement type - this is critical!
    if (agreementType && agreementType.length > 0) {
        fileNameParts.push(agreementType);
    } else {
        Logger.log("WARNING: No agreement type provided for file naming!");
        fileNameParts.push("Document"); // Fallback if no type
    }
    
    // Add the contract number
    if (finalContractNumber) {
        fileNameParts.push(finalContractNumber);
    }
    
    // Join with " - " separator
    const fileName = fileNameParts.filter(part => part && part.length > 0).join(" - ");
    
    Logger.log(`Final filename will be: "${fileName}"`);

    // Sanitize HTML content
    html = sanitizeHtml(html);

    // Create blob and file
    const blob = Utilities.newBlob(html, MimeType.HTML, `${fileName}.html`);
    const file = DriveApp.createFile(blob);

    // Convert to Google Doc
    const docFile = Drive.Files.copy(
        {
            title: fileName,
            mimeType: MimeType.GOOGLE_DOCS,
        },
        file.getId()
    );

    file.setTrashed(true);

    Logger.log("Google Docs File ID: " + docFile.id);
    return docFile.id;
}

// Also ensure processAndCreateFile is passing the data correctly
function processAndCreateFile(docData, subfolder) {
    if (!docData) {
        Logger.log("processAndCreateFile skipped because docData was null.");
        return;
    }

    // Destructure all needed properties from the data object
    const {
        agreementType, 
        language, 
        firstParty, 
        counterparty,
        contractNumber
    } = docData;
    
    // Log what we're working with
    Logger.log(`processAndCreateFile - Processing document:`);
    Logger.log(`  agreementType: "${agreementType}"`);
    Logger.log(`  language: "${language}"`);
    Logger.log(`  contractNumber: "${contractNumber}"`);
    
    // Ensure we have an agreement type
    if (!agreementType) {
        Logger.log("ERROR: No agreementType in docData!");
        throw new Error("Missing agreementType in document data");
    }

    // Generate a number if one isn't already set
    const finalContractNumber = contractNumber || generateContractNumber(agreementType);
    docData.contractNumber = finalContractNumber; 

    Logger.log("docData going into prompt:\n" + JSON.stringify(docData, null, 2));

    const role = 'This GPT is designated to generate realistic sample agreements for use during AI demonstrations. It is tailored to create agreements with specific legal language and conditions that can be analyzed to return structured information.';
    const prompt = createPrompt(docData);

    try {
        const responseFromOpenAI = PreSalesOpenAI.executePrompt4o(role, prompt);

        // Pass all parameters explicitly and verify they exist
        Logger.log(`Calling createFileInDriveV3 with:`);
        Logger.log(`  agreementType: "${agreementType}"`);
        Logger.log(`  language: "${language || 'English'}"`);
        Logger.log(`  contractNumber: "${finalContractNumber}"`);
        
        const newFileId = createFileInDriveV3(
            responseFromOpenAI, 
            agreementType, 
            language || 'English', 
            finalContractNumber
        );

        const newFile = DriveApp.getFileById(newFileId);
        newFile.moveTo(subfolder);
        newFile.setDescription(`Template for ${firstParty} and ${counterparty}`);

    } catch (error) {
        Logger.log(`Failed to create document for ${agreementType} with ${counterparty}. Original Error: ${error.message}`);
        throw new Error(`Failed for ${agreementType}. Details: ${error.message}`);
    }
}

// Proper sanitization function
function sanitizeHtml(html) {
    // Strip out any leftover code block tags
    html = html.replace(/```html|```/g, "").trim();

    // Escape your special markers once, globally, instead of brute-forcing 100 loops
    html = html.replace(/<# </g, "&lt;# &lt;").replace(/> #>/g, "&gt; #&gt;");

    return html;
}
