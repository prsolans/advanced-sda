// 08_jsonFormatter.js
// Converts structured JSON from OpenAI into professional HTML documents
// Handles all formatting, styling, and layout in post-processing

/**
 * Main function to convert JSON document data to professional HTML
 * @param {Object} jsonData - Structured document data from OpenAI
 * @param {Object} docData - Document metadata (parties, contract number, etc.)
 * @returns {string} - Complete HTML document
 */
function convertJsonToHtml(jsonData, docData) {
  try {
    // Parse JSON if it's a string
    const documentData = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
    
    // Build HTML components
    const header = buildDocumentHeader(documentData, docData);
    const preamble = buildPreamble(documentData.preamble, docData);
    const recitals = buildRecitals(documentData.recitals, docData);
    const sections = buildSections(documentData.sections);
    const signatures = createSignatureBlock(docData, docData.effectiveDate || new Date());
    
    // Combine into complete document
    const htmlContent = [
      getDocumentStyles(),
      '<body>',
      header,
      preamble, 
      recitals,
      sections,
      signatures,
      '</body>',
      '</html>'
    ].join('\n');
    
    return addHtmlWrapper(htmlContent);
    
  } catch (error) {
    Logger.log(`ERROR in JSON to HTML conversion: ${error.message}`);
    return generateErrorDocument(docData, error.message);
  }
}

/**
 * Build standardized document header with language support
 */
function buildDocumentHeader(documentData, docData) {
  const documentType = documentData.documentType || docData.agreementType || 'AGREEMENT';
  const contractNumber = docData.contractNumber || 'DRAFT';
  const language = normalizeLanguage(docData.language || 'English');
  const translations = getLanguageTranslations(language);
  
  return `
<div class="document-header">
  <h1>${documentType.toUpperCase()}</h1>
  <h2>${translations.contractNo}: ${contractNumber}</h2>
</div>`;
}

/**
 * Build preamble section from structured data with language support
 */
function buildPreamble(preambleData, docData) {
  if (!preambleData) return '';
  
  const parties = preambleData.parties || [];
  const effectiveDate = preambleData.effectiveDate || new Date().toLocaleDateString();
  const documentType = preambleData.documentType || 'Agreement';
  const language = normalizeLanguage(docData.language || 'English');
  const translations = getLanguageTranslations(language);
  
  // Build preamble preserving AI-generated content for all languages
  // The AI should generate proper preamble content in JSON, so we just structure it
  let preambleHtml = '<div class="preamble">';
  
  if (preambleData.content) {
    // If AI provided structured preamble content, use it
    preambleHtml += preambleData.content;
  } else {
    // Fallback: build from party data, but let AI handle the language
    // This should rarely be used if AI generates proper JSON
    const parties = preambleData.parties || [];
    const effectiveDate = preambleData.effectiveDate || new Date().toLocaleDateString();
    const documentType = preambleData.documentType || 'Agreement';
    
    if (language === 'English') {
      preambleHtml += `<p>THIS ${documentType.toUpperCase()} ("Agreement") is entered into as of ${effectiveDate} ("Effective Date") by and between:</p>`;
      parties.forEach((party, index) => {
        preambleHtml += `<p><strong>${party.name}</strong>, a ${party.type} organized under the laws of ${party.jurisdiction || 'the United States'} ("${index === 0 ? 'Company' : 'Counterparty'}"); and</p>`;
      });
    } else {
      // For non-English, provide minimal structure and let post-processing handle translation
      preambleHtml += `<p>[Preamble content generated by AI in ${language}]</p>`;
    }
  }
  
  preambleHtml += `</div>`;
  return preambleHtml;
}

/**
 * Build recitals section with language support
 */
function buildRecitals(recitals, docData) {
  if (!recitals || !Array.isArray(recitals)) return '';
  
  const language = normalizeLanguage(docData.language || 'English');
  const translations = getLanguageTranslations(language);
  
  let recitalsHtml = '<div class="recitals">';
  recitals.forEach((recital, index) => {
    // Clean recital text to prevent duplicate "WHEREAS" in any language
    let cleanRecital = recital.trim();
    const whereasVariations = ['WHEREAS', 'CONSIDERANDO QUE', 'CONSIDÉRANT QUE', 'WOHINGEGEN', '鑑みて'];
    
    for (const whereas of whereasVariations) {
      if (cleanRecital.toUpperCase().startsWith(whereas.toUpperCase())) {
        cleanRecital = cleanRecital.substring(whereas.length).trim();
        if (cleanRecital.startsWith(',')) {
          cleanRecital = cleanRecital.substring(1).trim();
        }
        break;
      }
    }
    
    recitalsHtml += `<p><strong>${translations.whereas}</strong>, ${cleanRecital}${index === recitals.length - 1 ? '; and' : ''}</p>`;
  });
  recitalsHtml += `<p><strong>${translations.nowTherefore}</strong>, ${translations.inConsideration}:</p>`;
  recitalsHtml += '</div>';
  
  return recitalsHtml;
}

/**
 * Build main document sections
 */
function buildSections(sections) {
  if (!sections || !Array.isArray(sections)) return '';
  
  let sectionsHtml = '<div class="document-sections">';
  
  sections.forEach(section => {
    sectionsHtml += `<div class="section">
<p class="section-header">${section.number}. ${section.title}</p>`;
    
    if (section.content && Array.isArray(section.content)) {
      // Handle definitions section with term/definition pairs
      section.content.forEach(item => {
        if (item.term && item.definition) {
          sectionsHtml += `<p><strong>"${item.term}"</strong> means ${item.definition}</p>`;
        } else {
          sectionsHtml += `<p>${item}</p>`;
        }
      });
    } else if (section.paragraphs && Array.isArray(section.paragraphs)) {
      // Handle regular paragraphs
      section.paragraphs.forEach(paragraph => {
        sectionsHtml += `<p>${paragraph}</p>`;
      });
    } else if (section.content) {
      // Handle single content block
      sectionsHtml += `<p>${section.content}</p>`;
    }
    
    sectionsHtml += '</div>';
  });
  
  sectionsHtml += '</div>';
  return sectionsHtml;
}

/**
 * Get comprehensive document styles
 */
function getDocumentStyles() {
  return `<!DOCTYPE html>
<html>
<head>
<style>
@page {
  margin: 1in;
}
body {
  font-family: 'Times New Roman', serif;
  font-size: 12pt;
  line-height: 1.15;
  margin: 1in;
  padding: 0;
  color: #000;
}
.document-header {
  text-align: center;
  margin-bottom: 15pt;
  page-break-inside: avoid;
}
.document-header h1 {
  font-size: 16pt;
  font-weight: bold;
  margin: 0 0 4pt 0;
  text-transform: uppercase;
  letter-spacing: 1pt;
}
.document-header h2 {
  font-size: 12pt;
  font-weight: normal;
  margin: 0 0 8pt 0;
  color: #666;
}
.preamble {
  margin-bottom: 12pt;
}
.recitals {
  margin-bottom: 4pt;
}
.section {
  margin-bottom: 9pt;
}
.section-header {
  font-weight: bold;
  font-size: 12pt;
  margin: 9pt 0 6pt 0;
  text-transform: uppercase;
}
p {
  margin: 0 0 6pt 0;
  text-align: justify;
  text-indent: 0;
}
strong {
  font-weight: bold;
}
.signature-block {
  margin-top: 18pt;
  page-break-inside: avoid;
}
.signature-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 12pt;
}
.signature-table td {
  width: 50%;
  vertical-align: top;
  padding: 6pt;
  border: none;
}
.signer-name {
  font-weight: bold;
  margin-bottom: 6pt;
}
.signer-title {
  margin-bottom: 24pt;
  font-style: italic;
}
.signature-line {
  border-bottom: 1pt solid black;
  height: 24pt;
  margin-bottom: 6pt;
}
.signature-date {
  font-size: 11pt;
}
</style>
</head>`;
}

/**
 * Add HTML wrapper if needed
 */
function addHtmlWrapper(content) {
  if (content.includes('<!DOCTYPE html>')) {
    return content;
  }
  return `<!DOCTYPE html><html><head></head>${content}`;
}

/**
 * Generate error document for debugging
 */
function generateErrorDocument(docData, errorMessage) {
  return `<!DOCTYPE html><html><head><title>Generation Error</title></head><body>
<h1>Document Generation Error</h1>
<p><strong>Error:</strong> ${errorMessage}</p>
<p><strong>Document Type:</strong> ${docData.agreementType || 'Unknown'}</p>
<p><strong>Contract Number:</strong> ${docData.contractNumber || 'Unknown'}</p>
<p>Please check the OpenAI response format and try again.</p>
</body></html>`;
}